---
layout: post
title:  "Persistence in Programming"
description: "An article discussing the need for (smart) presistence when learning programming."
date:   2017-08-18 08:57:00 +0800
categories: programming
---

I spent most of my high school years either playing videogames or occupied with my studies. I still very much enjoyed programming, but that was a pastime that I couldn't really relish in without a major time investment. With my high school final year exam approaching, my schoolmates and I were focused on revising for the ten (yes, 10!) subjects we were to take. My code was put aside in favour of calculus, linguistics and the sciences. (Ironically, I scored an A- for my biology, a subject I couldn't have cared less about.) I was going through a tough time in my life as well, and when I was not playing videogames, I was reading fiction. So my (average) programming skills took a back seat while I hit the books and I wouldn't have gone back to it until after that final exam.

Fast forward a year later, when I enrolled in my current university. I sat for my very first programming class in, erm, Visual Basic. I generally liked the lessons, but as for Visual Basic, I **hated** it. The syntax drove me nuts, coming from a C++ background. It didn't help that I didn't understand the obscure API calls that pervaded Windows's .NET framework. I managed to get through the subject with good grades. (Apparently, the programming language for that subject changed to Python, a move which I welcomed.) Having been a self-taught programmer, I got the upper hand when it came to solving programming problems, and I was quite satisfied with my current skill-level. But boy, was I in for a rude awakening.

*Knowledge is Power.* What a hypnotic phrase. I was obssessed with it from the minute I saw those words printed over the computer lab in my primary school. I loved hording my knowledge, to the point that knowledge was everything to me. Even back then, I was filled with pride as I helped my classmates debug Windows 98 error messages, thanks to my good grasp of English (I was in a non-English medium school). We didn't do any programming, but it was fun messing around with MS Paint. Over the years, I would pride myself in being the smart alec, the one who knew stuff and was ahead of the crowd. 

The time would come when a university subject required me to code in C. I took the subject rather lightly, treating what I learned to complement my C++ knowledge. I refused to use a buggy and outdated IDE that my subject forced me to use, and I paid for that in lost marks. Realizing my mistake, I eventually used the IDE, albeit not directly: I used a separate text editor (the one in the IDE was buggy as hell) to edit my code and compiled the code in the IDE itself. The result: a lesson learnt and full marks for my final assignment. (Truth to be told, my code was far from ideal, but the lecturer, to put it politely, probably thought it was the best in his inexperience of teaching programming.)

In retrospect, my impatience had driven me to be brash rather than careful, careless rather than aware. My goal was to quickly get my programming done and over with and focus on my other core subjects. I could have taken my time to experiment by trial-and-error, but time restraints prompted me to rush through it. Was I persistent? No. Was I open to ideas? Probably not. I was fixated on my existing knowledge, foolishly thinking that it was enough to pull me through with lesser effort than my peers.

As of the time of writing, I am more willing to accept ideas and challenge my existing ones if need be. While I realize that I must learn to be more persistent, I still hold onto the notion of working smart rather than working hard, but I suppose working smart and hard at the same time is a possible feat. Reevaluating my principles allowed me see my shortcomings, and I adjusted my mindset by striving to learn more about programming, in theory and practice. I am still a long way from writing any killer app, but being the practical guy, I'll probably stick to writing programs that actually do something useful.